#1: from collections import deque
 
 def find_path(maze):
    def is_valid(x, y):
        return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] in ('0', 'G')
 
    def get_neighbors(x, y):
        return [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
 
    start_x, start_y = None, None
 
    # Find the starting point
    for i in range(len(maze)):
        for j in range(len(maze[0])):
            if maze[i][j] == 'S':
                start_x, start_y = i, j
                break
 
    if start_x is None or start_y is None:
        return None
 
    # Initialize the BFS queue with the starting point
    queue = deque([(start_x, start_y, [])])
 
    while queue:
        x, y, path = queue.popleft()
 
        if maze[x][y] == 'G':
            return path
 
        maze[x][y] = '1'  # Mark visited cells
 
        for neighbor_x, neighbor_y in get_neighbors(x, y):
            if is_valid(neighbor_x, neighbor_y):
                new_path = path + [(neighbor_x, neighbor_y)]
                queue.append((neighbor_x, neighbor_y, new_path))
 
    return None  # No path found
 
 maze = [
    ['S', '1', '1', '1', '1'],
    ['0', '0', '1', '1', '1'],
    ['1', '1', '1', '0', '0'],
    ['1', '0', '0', '0', '1'],
    ['1', '1', '1', '1', 'G']
 ]
 
 path = find_path(maze)
 
 if path:
    print("Path found:")
    for x, y in path:
        print(f"({x}, {y})")
 else:
    print("No path found") 
 #2:  import random
 
 class City:
    def __init__(self, name, x, y):
        self.name = name
        self.x = x
        self.y = y
 
    def distance_to(self, other_city):
        return ((self.x - other_city.x)**2 + (self.y - other_city.y)**2)**0.5
 
 class Chromosome:
    def __init__(self, cities):
        self.cities = cities
        self.fitness = None
 
    def calculate_fitness(self):
        total_distance = 0
        for i in range(len(self.cities) - 1):
            total_distance += self.cities[i].distance_to(self.cities[i + 1])
 
        # The fitness is the inverse of the total distance, so that better chromosomes have a higher fitness.
        self.fitness = 1.0 / total_distance
 
    def crossover(self, other_chromosome):
        # Select a random crossover point.
        crossover_point = random.randint(1, len(self.cities) - 2)
 
        # Create two new chromosomes by swapping the genes after the crossover point.
        child_1 = Chromosome(self.cities[:crossover_point] + other_chromosome.cities[crossover_point:])
        child_2 = Chromosome(other_chromosome.cities[:crossover_point] + self.cities[crossover_point:])
 
        return child_1, child_2
 
    def mutate(self):
        # Select two random genes to swap.
        gene_1 = random.randint(0, len(self.cities) - 1)
        gene_2 = random.randint(0, len(self.cities) - 1)
 
        # Swap the genes.
        self.cities[gene_1], self.cities[gene_2] = self.cities[gene_2], self.cities[gene_1]
 
 class Population:
    def __init__(self, chromosomes):
        self.chromosomes = chromosomes
 
    def select_parents(self):
        # Select two parents using the roulette wheel selection method.
        parents = []
        for i in range(2):
            total_fitness = 0.0
            for chromosome in self.chromosomes:
                total_fitness += chromosome.fitness
 
            # Generate a random number between 0 and the total fitness.
            random_number = random.random() * total_fitness
 
            # Find the chromosome whose fitness is greater than or equal to the random number.
            current_fitness = 0.0
            for chromosome in self.chromosomes:
                current_fitness += chromosome.fitness
                if current_fitness >= random_number:
                    parents.append(chromosome)
                    break
 
        return parents
 
    def crossover(self):
        # Create a new population by crossing over the parents.
        new_population = []
        for i in range(len(self.chromosomes)):
            parents = self.select_parents()
            child_1, child_2 = parents[0].crossover(parents[1])
            new_population.append(child_1)
            new_population.append(child_2)
 
        return new_population
 
    def mutate(self, mutation_rate):
        # Mutate each chromosome in the population with a probability equal to the mutation rate.
        for chromosome in self.chromosomes:
            if random.random() < mutation_rate:
                chromosome.mutate()
 
    def get_best_chromosome(self):
        # Return the chromosome with the highest fitness.
        best_chromosome = None
        for chromosome in self.chromosomes:
            if best_chromosome is None or chromosome.fitness > best_chromosome.fitness:
                best_chromosome = chromosome
 
        return best_chromosome
 
 
 def main():
    # Create a list of cities.
    cities = [
        City("Start", 0, 0),
        City("A", 10, 10),
        City("B", 11, 11),
        City("C", 12, 12),
    ]
 
    # Create a population of chromosomes.
    population = Population([Chromosome(random.sample(cities, len(cities))) for i in range(100)])         # Evolve the population until the best chromosome has a fitness of 1.0, or until a maximum number of generations is reached.
    max_generations = 1000
    generation_count = 0
    while population.get_best_chromosome().fitness < 1.0 and generation_count < max_generations:
        generation_count += 1
 
        # Select the best chromosomes to be the parents of the next generation.
        parents = population.select_parents()
 
        # Create a new population by crossing over the parents and mutating the children.
        new_population = population.crossover()
        new_population.mutate(0.1)
 
        population = new_population
 
    # Return the best chromosome.
    best_chromosome = population.get_best_chromosome()
 
    # Print the shortest path.
    print("Shortest path:")
    for city in best_chromosome.cities:
        print(city.name)
﻿
 
 
 #3:  count_terminal = 0
 def alphabeta(state, depth, alpha, beta, isMaxPlayer):
    global count_terminal
    if (depth == 0) or terminal_node(state)["gameover"]: 
       count_terminal += 1
       return  terminal_node(state)["result"]
 
    if isMaxPlayer: # player maximizes his score
        v_max = -math.inf
        children = expand_state(state)
        for pos in children:
            child = copy.deepcopy(state)
            child[pos[0]][pos[1]] = 1
            v = alphabeta(child, depth - 1, alpha, beta, not isMaxPlayer)
            v_max = max(v_max, v)
            alpha = max(alpha, v)
            if beta <= alpha:
                break
        return v_max
    else: # player minimizes his score
        v_min = math.inf
        children = expand_state(state)
        for pos in children:
            child = copy.deepcopy(state)
            child[pos[0]][pos[1]] = -1
            v = alphabeta(child, depth - 1, alpha, beta, not isMaxPlayer)
            v_min = min(v_min, v)
            beta = min(beta, v)
            if beta <= alpha:
                break
        return v_min
 count_terminal = 0
 state = [[0, 0, 0],[0,0,0],[0,0,-1]]
 depth = 8
 alpha = -math.inf
 beta = math.inf
 isMaxPlayer = True
 v = alphabeta(state, depth, alpha, beta, isMaxPlayer)
 print(v)
 print(count_terminal)
